---
title: PassingCars
tags:
  - PHP
  - codility
private: false
updated_at: '2019-01-22T21:37:29+09:00'
id: 7911f500edba12c2b6f3
organization_url_name: null
slide: false
ignorePublish: false
---
まず、所感から入る。

**難解だ。**
何を言っているのか分からない。東西に走る車の通過数を答えろ、というような設問だが、何を答えればいいのか判然としない。

どうしても分からないため、[答え][a]を参考に、設問の意味の理解に努めた。
すると、ようやく分かった。

例えば、以下の配列が与えられたとする。

  A[0] = 0
  A[1] = 1
  A[2] = 0
  A[3] = 1
  A[4] = 1

このとき、A[0] ～ A[4] まで５つの車が存在し、それぞれの車が東に向かう（[0]）か、西に向かう
（[1]）かが示されている。
例えば、A[0] = 0 は、１台目の車が東に向かうことを意味し、A[1] = 0 は、２台目の車が西に向かうことを意味する。
なので、この時点で一つの組が生まれる。それは、(0, 1) になる。なぜなら、１台目と２台目がpassing (≒行き違う）しているからである。残りの A[2] ～ A[4] においても行き違う車の組を探し、組の数を数える、という問題。

## [1st][a]

今回は、上記[答え][a]のコードを見て設問の意味を理解したため、コード自体が頭に残っており、自分でコードを考えても、どうしても先人のコードが脳裏をよぎり、その考え方から離れられなかったため、考え方は先人のコードのものとなっている。

<table>
    <tr><th>正確性</th><th>性能</th><th>スコア</th></tr>
    <tr>
        <td>100%</td>
        <td>100%</td>
        <td>100%</td>
    </tr>
</table>

```php
function solution($A) {
    $cnt = 0;
    $east = 0;

    foreach($A as $value) {
        // Count cars traveling east
        if(0 == $value) {
            $east++;
        // Count pairs of cars passing
        } else {
            $cnt += $east;
            // If the number of pairs exceeds 1,000,000,000, return -1
            if($cnt > 1000000000) {
                return -1;
            }
        }
    }
    return $cnt;
}
```

考え方は先人と同じで、先人のコードは java で書かれていたため`for`ループだったが、このコードはPHP なので、`foreach`を使った、というのが唯一の違い。（変数名も少し違う。）

この考え方は、東に向かう車(east)が増えた分、西に向かう車(west)と行き違う数も増えるため、加算代入によって west += east とするもの。配列の要素の値が 0 のときはもちろん east++ となるだけ。
かなりシンプルで分かりやすい考え方。

対して、最初に筆者が考えたのは、組み合わせとして解けないか、というもの。配列のすべての要素を異なる値ととらえ、考えられる (0, 1) の組み合わせをすべて数えれば、答えになるはず。だが、この場合、恐らく `O(N^2)` の計算量となるため、性能要件でアウト。というより、そもそもコードに表現し切れない気がする。ぱっと調べた感じ、C言語では、再帰的関数を使って実現しているよう。
まあ、こういう**難しそう**を一つずつ解決していくことでスキルが向上していくんやろうけど。
悲しいかな、やる気が出ない。

<!-- 以下、参考 URL -->
[a]: http://codility-lessons-jp.blogspot.jp/2014/07/lesson-3-passing-cars.html
[b]: https://app.codility.com/demo/results/training46B3XF-ZYG/
<!-- 以下、Codility 和訳
N個の整数からなる空でないゼロインデックスな配列Aがある。
配列Aの連続な要素は、道路上を走る連続した車を表す。

配列Aは複数の0 and/or 1を含む配列である：

０は東に向かう車を表す。
１は西に向かう車を表す。
目的は、通過する車を数えることである。
一組の車(P, Q)が 0 ≤ P < Q < N のとき、Pは東に向かい、Qは西に向かい、行き違っている。

例えば、配列Aが次の場合：

  A[0] = 0
  A[1] = 1
  A[2] = 0
  A[3] = 1
  A[4] = 1

５組の通過する車があるということだ: (0, 1), (0, 3), (0, 4), (2, 3), (2, 4).

次のように関数を書け：

function solution($A);

これは、N個の整数からなる空でないゼロインデックスの配列Aが与えられたとき、行き違う車の組の数を
返すものである。

その関数は、行き違う車の組の数が1,000,000,000を超えた時、-1を返す。

例えば：

  A[0] = 0
  A[1] = 1
  A[2] = 0
  A[3] = 1
  A[4] = 1
上で説明した通り、その関数は5を返す。
-->
